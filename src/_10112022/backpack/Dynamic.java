package _10112022.backpack;

import java.util.ArrayList;
//В данном случае сложность нашего алгоритма будет
//O(wn)
public class Dynamic {
    public static void main(String[] args) {
        //массив объемов предметов
        int[] weights = {3, 4, 5, 8, 9};

        //стоимость предметов
        int[] prices = {1, 6, 4, 7, 6};

        int count = weights.length;

        //объем рюкзака
        int maxWeight = 13;

        //таблица оптимальных стоимостей
        int[][] A;
        /**
         * в первом индексе будет количество предметов
         * во втором индексе размер рюкзака
         * само значение это максимальная стоимость для соответствующего рюкзака
         * и набора предметов
         */
        A = new int[count + 1][];
        for (int i = 0; i < count + 1; i++) {
            A[i] = new int[maxWeight + 1];
        }

        //k - это размер наборов предметов
        //s - это размер рюкзака
        for (int k = 0; k <= count; k++) {
            for (int s = 0; s <= maxWeight; s++) {
                //если наш размер наборов предметов равен 0 или рюкзак 0
                //то, никакой стоимости быть не может
                if (k == 0 || s == 0) {
                    A[k][s] = 0;
                } else {
                    //если размер нашего рюкзака больше или равен размеру
                    //текущего предмета
                    if (s >= weights[k - 1]) {
                        /**
                         * если предмет помещается
                         * то, максимальная стоимость соответствующего набора будет равняться.....
                         */

                        /**
                         * если предмет кладется или НЕ кладется в рюкзак
                         * то, мы выбираем из них максимальный.
                         */

                        /**
                         * Если мы не кладем предмет в рюкзак:
                         * Стоимость набора будет той же без учета К-го предмета,
                         * поэтому стоимость будет A[k - 1][s].
                         * Если мы кладем предмет в рюкзак:
                         * Тогда стоимость набора буде без К-го предмета
                         * A[k - 1][s - weights[k - 1] + prices[k - 1]]
                         */

                        A[k][s] = Math.max(A[k - 1][s], A[k - 1][s - weights[k - 1]] + prices[k - 1]);
                    } else {
                        //если предмет в рюкзак не влезет, то и класть его не надо
                        //стоимость == оптимальной стоимости только без К-го предмета
                        A[k][s] = A[k - 1][s];
                    }
                }
            }
        }

        ArrayList<Integer> result = new ArrayList<>();
        //вызываем метод и передаем матрицу и остальные параметры

        traceResult(A, weights, count, maxWeight, result);
        System.out.println("Оптимальное содержание рюкзака: ");
        for (Integer integer : result) {
            System.out.println(integer);
        }
    }

    //Напишем алгоритм перебора таблицы.
    //Передадим в качестве параметра нашу матрицу стоимостей,
    //вес предмета, размер наборов, размер рюкзака, и еще
    //можно туда передать ЛИСТ для накопления оптимальных наборов
    private static void traceResult(int[][] A, int[] weight, int k, int s, ArrayList<Integer> result) {
        //если стоимость A[k][s] == 0
        if (A[k][s] == 0) {
            //то ничего не надо добавлять
            return;
        }

        //стоимость без К-го предмета равно стоимости с К-ым предметом,
        //а это значит что К-ый предмет в этом случае не участвует,
        //и мы дальше идем по таблице без учета этого предмета
        if (A[k - 1][s] == A[k][s]) {
            //просто идем и уменьшаем набор на 1
            traceResult(A, weight, k - 1, s, result);
        } else {
            //иначе этот предмет участвует в формировании нашего оптимального набора,
            //далее продолжаем проходиться по таблице без К-го предмета и рюкзак уменьшаем на вес
            //К-го предмета, а сам предмет кладем в ЛИСТ тк он присутствует в нашем решении
            traceResult(A, weight, k - 1, s - weight[k - 1], result);
            result.add(0, k);
        }
    }
}